{
    "docs": [
        {
            "location": "/",
            "text": "Roact-Rodux is the official binding layer between \nRoact\n, a view library, and \nRodux\n, a state management library.",
            "title": "Home"
        },
        {
            "location": "/guide/installation/",
            "text": "First, install \nRoact\n and \nRodux\n into the same place you intend to install Roact-Rodux. For these examples, we'll install everything into \nReplicatedStorage\n.\n\n\nMethod 1: Model File (Roblox Studio)\n\u00b6\n\n\n\n\nDownload the \nrbxmx\n model file attached to the latest release from the \nGitHub releases page\n\n\nInsert the model into Studio into a place like \nReplicatedStorage\n\n\n\n\nMethod 2: Rojo\n\u00b6\n\n\n\n\nCopy the \nlib\n directory into your codebase\n\n\nRename the folder to \nRoactRodux\n\n\nUse \nRojo\n to sync the files into a place",
            "title": "Installation"
        },
        {
            "location": "/guide/installation/#method-1-model-file-roblox-studio",
            "text": "Download the  rbxmx  model file attached to the latest release from the  GitHub releases page  Insert the model into Studio into a place like  ReplicatedStorage",
            "title": "Method 1: Model File (Roblox Studio)"
        },
        {
            "location": "/guide/installation/#method-2-rojo",
            "text": "Copy the  lib  directory into your codebase  Rename the folder to  RoactRodux  Use  Rojo  to sync the files into a place",
            "title": "Method 2: Rojo"
        },
        {
            "location": "/guide/usage/",
            "text": "Create a Store with Rodux\n\u00b6\n\n\nCreate your store as normal with \nRodux\n:\n\n\nlocal\n \nfunction\n \nreducer\n(\nstate\n,\n \naction\n)\n\n    \nstate\n \n=\n \nstate\n \nor\n \n{\n\n        \nvalue\n \n=\n \n0\n,\n\n    \n}\n\n\n    \nif\n \naction\n.\ntype\n \n==\n \n\"increment\"\n \nthen\n\n        \nreturn\n \n{\n\n            \nvalue\n \n=\n \nstate\n.\nvalue\n \n+\n \n1\n,\n\n        \n}\n\n    \nend\n\n\n    \nreturn\n \nstate\n\n\nend\n\n\n\nlocal\n \nstore\n \n=\n \nRodux\n.\nStore\n.\nnew\n(\nreducer\n)\n\n\n\n\n\nAdd a \nStoreProvider\n\u00b6\n\n\nWhen you render your Roact application, wrap the top-level component in a \nRoactRodux.StoreProvider\n:\n\n\nlocal\n \napp\n \n=\n \nRoact\n.\ncreateElement\n(\nRoactRodux\n.\nStoreProvider\n,\n \n{\n\n    \nstore\n \n=\n \nstore\n,\n\n\n},\n \n{\n\n    \nMain\n \n=\n \nRoact\n.\ncreateElement\n(\nMyComponent\n),\n\n\n})\n\n\n\n\n\nThis makes your Rodux store available for any components in your app. They'll access that store using the \nconnect\n function.\n\n\nConnect with \nconnect\n\u00b6\n\n\nUse \nRoactRodux.connect\n to retrieve values from the store and use them in your \nRoact\n component:\n\n\n-- Write your component as if Rodux is not involved first.\n\n\n-- This helps guide you to create a more focused interface.\n\n\n\nlocal\n \nfunction\n \nMyComponent\n(\nprops\n)\n\n    \n-- Values from Rodux can be accessed just like regular props\n\n    \nlocal\n \nvalue\n \n=\n \nprops\n.\nvalue\n\n    \nlocal\n \nonClick\n \n=\n \nprops\n.\nonClick\n\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"ScreenGui\"\n,\n \nnil\n,\n \n{\n\n        \nLabel\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextButton\"\n,\n \n{\n\n            \n-- ...and used in your components!\n\n            \nText\n \n=\n \n\"Current value: \"\n \n..\n \nvalue\n,\n\n            \nSize\n \n=\n \nUDim2\n.\nnew\n(\n1\n,\n \n0\n,\n \n1\n,\n \n0\n),\n\n\n            \n[\nRoact\n.\nEvent\n.\nActivated\n]\n \n=\n \nonClick\n,\n\n        \n})\n\n    \n})\n\n\nend\n\n\n\n-- `connect` accepts two optional functions:\n\n\n-- `mapStateToProps` accepts your store's state and returns props\n\n\n-- `mapDispatchToProps` accepts a dispatch function and returns props\n\n\n\n-- Both functions should return a table containing props that will be passed to\n\n\n-- your component!\n\n\n\n-- `connect` returns a function, so we call that function, passing in our\n\n\n-- component, getting back a new component!\n\n\nMyComponent\n \n=\n \nRoactRodux\n.\nconnect\n(\n\n    \nfunction\n(\nstate\n,\n \nprops\n)\n\n        \n-- mapStateToProps is run every time the store's state updates.\n\n        \n-- It's also run whenever the component receives new props.\n\n        \nreturn\n \n{\n\n            \nvalue\n \n=\n \nstate\n.\nvalue\n,\n\n        \n}\n\n    \nend\n,\n\n    \nfunction\n(\ndispatch\n)\n\n        \n-- mapDispatchToProps only runs once, so create functions here!\n\n        \nreturn\n \n{\n\n            \nonClick\n \n=\n \nfunction\n()\n\n                \ndispatch\n({\n\n                    \ntype\n \n=\n \n\"increment\"\n,\n\n                \n})\n\n            \nend\n,\n\n        \n}\n\n    \nend\n\n\n)(\nMyComponent\n)\n\n\n\n\n\nNow, whenever the store updates, your connected components will receive updated data and re-render!\n\n\nIn many ways, Roact-Rodux works just like \nreact-redux\n. The public API is almost identical and most of the best practices from that ecosystem work here as well.",
            "title": "Using Roact-Rodux"
        },
        {
            "location": "/guide/usage/#create-a-store-with-rodux",
            "text": "Create your store as normal with  Rodux :  local   function   reducer ( state ,   action ) \n     state   =   state   or   { \n         value   =   0 , \n     } \n\n     if   action . type   ==   \"increment\"   then \n         return   { \n             value   =   state . value   +   1 , \n         } \n     end \n\n     return   state  end  local   store   =   Rodux . Store . new ( reducer )",
            "title": "Create a Store with Rodux"
        },
        {
            "location": "/guide/usage/#add-a-storeprovider",
            "text": "When you render your Roact application, wrap the top-level component in a  RoactRodux.StoreProvider :  local   app   =   Roact . createElement ( RoactRodux . StoreProvider ,   { \n     store   =   store ,  },   { \n     Main   =   Roact . createElement ( MyComponent ),  })   This makes your Rodux store available for any components in your app. They'll access that store using the  connect  function.",
            "title": "Add a StoreProvider"
        },
        {
            "location": "/guide/usage/#connect-with-connect",
            "text": "Use  RoactRodux.connect  to retrieve values from the store and use them in your  Roact  component:  -- Write your component as if Rodux is not involved first.  -- This helps guide you to create a more focused interface.  local   function   MyComponent ( props ) \n     -- Values from Rodux can be accessed just like regular props \n     local   value   =   props . value \n     local   onClick   =   props . onClick \n\n     return   Roact . createElement ( \"ScreenGui\" ,   nil ,   { \n         Label   =   Roact . createElement ( \"TextButton\" ,   { \n             -- ...and used in your components! \n             Text   =   \"Current value: \"   ..   value , \n             Size   =   UDim2 . new ( 1 ,   0 ,   1 ,   0 ), \n\n             [ Roact . Event . Activated ]   =   onClick , \n         }) \n     })  end  -- `connect` accepts two optional functions:  -- `mapStateToProps` accepts your store's state and returns props  -- `mapDispatchToProps` accepts a dispatch function and returns props  -- Both functions should return a table containing props that will be passed to  -- your component!  -- `connect` returns a function, so we call that function, passing in our  -- component, getting back a new component!  MyComponent   =   RoactRodux . connect ( \n     function ( state ,   props ) \n         -- mapStateToProps is run every time the store's state updates. \n         -- It's also run whenever the component receives new props. \n         return   { \n             value   =   state . value , \n         } \n     end , \n     function ( dispatch ) \n         -- mapDispatchToProps only runs once, so create functions here! \n         return   { \n             onClick   =   function () \n                 dispatch ({ \n                     type   =   \"increment\" , \n                 }) \n             end , \n         } \n     end  )( MyComponent )   Now, whenever the store updates, your connected components will receive updated data and re-render!  In many ways, Roact-Rodux works just like  react-redux . The public API is almost identical and most of the best practices from that ecosystem work here as well.",
            "title": "Connect with connect"
        },
        {
            "location": "/api-reference/",
            "text": "Roact Components\n\u00b6\n\n\nStoreProvider\n\u00b6\n\n\nStoreProvider\n accepts a Rodux store via the \nstore\n prop and makes it available to all components rendered under it.\n\n\nIt's possible to have multiple instances of \nStoreProvider\n in the same Roact tree, but most projects using Roact-Rodux will only have one.\n\n\nStoreProvider\n is generally at the top of the tree:\n\n\nRoact\n.\ncreateElement\n(\nRoactRodux\n.\nStoreProvider\n,\n \n{\n\n    \nstore\n \n=\n \nsomeStore\n,\n\n\n},\n \n{\n\n    \n-- Any components created by `App` will be able to connect to someStore by\n\n    \n-- using Roact-Rodux's `connect` method.\n\n    \nApp\n \n=\n \nRoact\n.\ncreateElement\n(\nApp\n),\n\n\n})\n\n\n\n\n\n\n\nWarning\n\n\nDue to limitations of Roact, \nStoreProvider\n can only have zero or one children. This requirement may be relaxed in the future \nwhen Roact supports fragments\n.\n\n\n\n\nMethods\n\u00b6\n\n\nconnect\n\u00b6\n\n\nConnects to the Rodux store attached to the Roact tree by \nStoreProvider\n, retrieving data from the store and optionally creating functions to dispatch actions.\n\n\nconnect\n is a \nHigher-Order Component\n (HOC), which means that it wraps an existing component and adds additional functionality to it. Any props passed to the wrapped component will also be passed to the component that \nconnect\n is wrapping.\n\n\nconnect\n accepts two functions, both of which are optional:\n\n\n\n\nmapStateToProps\n, which accepts the store's state as the first argument, as well as the props passed to the component.\n\n\nmapStateToProps\n is run whenever the Rodux store updates, as well as whenever the props passed to your component are updated.\n\n\n\n\n\n\nmapDispatchToProps\n, which accepts a function that dispatches actions to your store. It works just like \nStore:dispatch\n in Rodux!\n\n\nmapDispatchToProps\n is only run once per component instance.\n\n\n\n\n\n\n\n\nBoth \nmapStateToProps\n and \nmapDispatchToProps\n should return a table. These tables get merged into the props passed to the wrapped component.\n\n\n\n\nInfo\n\n\nmapStateToProps\n can also return a function. When it does, the returned function will be used to retrieve state from the store on each update. This is usually used when working with memoized functions, similar to Redux's supplemental \nReselect\n library.\n\n\n\n\nconnect\n returns a function that should be called with the component to wrap. This API is sort of funky, but exists as-is for two primary reasons:\n\n\n\n\nReusing the same connection for multiple components is useful, and can be used to create abstractions over \nconnect\n.\n\n\nSince both \nmapStateToProps\n and \nmapDispatchToProps\n are optional, keeping them separate helps make the Roact-Rodux API cleaner.\n\n\n\n\nBase example:\n\n\nlocal\n \nfunction\n \nMyComponent\n(\nprops\n)\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"TextButton\"\n,\n \n{\n\n        \nText\n \n=\n \nprops\n.\nvalue\n,\n\n\n        \n[\nRoact\n.\nEvent\n.\nActivated\n]\n \n=\n \nprops\n.\nonClick\n,\n\n    \n})\n\n\nend\n\n\n\nMyComponent\n \n=\n \nRoactRodux\n.\nconnect\n(\n\n    \nfunction\n(\nstate\n,\n \nprops\n)\n\n        \nreturn\n \n{\n\n            \nvalue\n \n=\n \nstate\n.\nvalue\n,\n\n        \n}\n\n    \nend\n,\n\n    \nfunction\n(\ndispatch\n)\n\n        \nreturn\n \n{\n\n            \nonClick\n \n=\n \nfunction\n()\n\n                \ndispatch\n({\n\n                    \ntype\n \n=\n \n\"increment\"\n,\n\n                \n})\n\n            \nend\n,\n\n        \n}\n\n    \nend\n\n\n)\n\n\n\n\n\nUsing the higher-order version of \nmapStateToProps\n:\n\n\nMyComponent\n \n=\n \nRoactRodux\n.\nconnect\n(\n\n    \nfunction\n()\n\n        \nlocal\n \ngetValue\n \n=\n \nmemoize\n(\nfunction\n(\nstate\n)\n\n            \nreturn\n \nstate\n.\nvalue\n\n        \nend\n)\n\n\n        \nreturn\n \nfunction\n(\nstate\n,\n \nprops\n)\n\n            \nreturn\n \n{\n\n                \nvalue\n \n=\n \ngetValue\n(\nstate\n),\n\n            \n}\n\n        \nend\n\n    \nend\n\n\n)\n\n\n\n\n\nThe (very complicated) API signature of \nconnect\n is:\n\n\nconnect([mapStateToProps, [mapDispatchToProps]]) -> (componentToWrap) -> wrappedComponent\nwhere\n    mapStateToProps:\n        (storeState, props) -> propsToMerge\n        OR\n        () -> (storeState, props) -> propsToMerge\n    mapDispatchToProps: (dispatchFn) -> propsToMerge",
            "title": "API Reference"
        },
        {
            "location": "/api-reference/#roact-components",
            "text": "",
            "title": "Roact Components"
        },
        {
            "location": "/api-reference/#storeprovider",
            "text": "StoreProvider  accepts a Rodux store via the  store  prop and makes it available to all components rendered under it.  It's possible to have multiple instances of  StoreProvider  in the same Roact tree, but most projects using Roact-Rodux will only have one.  StoreProvider  is generally at the top of the tree:  Roact . createElement ( RoactRodux . StoreProvider ,   { \n     store   =   someStore ,  },   { \n     -- Any components created by `App` will be able to connect to someStore by \n     -- using Roact-Rodux's `connect` method. \n     App   =   Roact . createElement ( App ),  })    Warning  Due to limitations of Roact,  StoreProvider  can only have zero or one children. This requirement may be relaxed in the future  when Roact supports fragments .",
            "title": "StoreProvider"
        },
        {
            "location": "/api-reference/#methods",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/api-reference/#connect",
            "text": "Connects to the Rodux store attached to the Roact tree by  StoreProvider , retrieving data from the store and optionally creating functions to dispatch actions.  connect  is a  Higher-Order Component  (HOC), which means that it wraps an existing component and adds additional functionality to it. Any props passed to the wrapped component will also be passed to the component that  connect  is wrapping.  connect  accepts two functions, both of which are optional:   mapStateToProps , which accepts the store's state as the first argument, as well as the props passed to the component.  mapStateToProps  is run whenever the Rodux store updates, as well as whenever the props passed to your component are updated.    mapDispatchToProps , which accepts a function that dispatches actions to your store. It works just like  Store:dispatch  in Rodux!  mapDispatchToProps  is only run once per component instance.     Both  mapStateToProps  and  mapDispatchToProps  should return a table. These tables get merged into the props passed to the wrapped component.   Info  mapStateToProps  can also return a function. When it does, the returned function will be used to retrieve state from the store on each update. This is usually used when working with memoized functions, similar to Redux's supplemental  Reselect  library.   connect  returns a function that should be called with the component to wrap. This API is sort of funky, but exists as-is for two primary reasons:   Reusing the same connection for multiple components is useful, and can be used to create abstractions over  connect .  Since both  mapStateToProps  and  mapDispatchToProps  are optional, keeping them separate helps make the Roact-Rodux API cleaner.   Base example:  local   function   MyComponent ( props ) \n     return   Roact . createElement ( \"TextButton\" ,   { \n         Text   =   props . value , \n\n         [ Roact . Event . Activated ]   =   props . onClick , \n     })  end  MyComponent   =   RoactRodux . connect ( \n     function ( state ,   props ) \n         return   { \n             value   =   state . value , \n         } \n     end , \n     function ( dispatch ) \n         return   { \n             onClick   =   function () \n                 dispatch ({ \n                     type   =   \"increment\" , \n                 }) \n             end , \n         } \n     end  )   Using the higher-order version of  mapStateToProps :  MyComponent   =   RoactRodux . connect ( \n     function () \n         local   getValue   =   memoize ( function ( state ) \n             return   state . value \n         end ) \n\n         return   function ( state ,   props ) \n             return   { \n                 value   =   getValue ( state ), \n             } \n         end \n     end  )   The (very complicated) API signature of  connect  is:  connect([mapStateToProps, [mapDispatchToProps]]) -> (componentToWrap) -> wrappedComponent\nwhere\n    mapStateToProps:\n        (storeState, props) -> propsToMerge\n        OR\n        () -> (storeState, props) -> propsToMerge\n    mapDispatchToProps: (dispatchFn) -> propsToMerge",
            "title": "connect"
        }
    ]
}